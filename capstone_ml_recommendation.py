# -*- coding: utf-8 -*-
"""capstone_ML_recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16fGcsyOnOves9B1eM5yL_46OHwyw_0z0

# new draft
"""

pip install Sastrawi

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.feature_extraction.text import TfidfVectorizer
from Sastrawi.Stemmer.StemmerFactory import StemmerFactory
from Sastrawi.StopWordRemover.StopWordRemoverFactory import StopWordRemoverFactory
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import OneHotEncoder
from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
from geopy.distance import geodesic


tv = TfidfVectorizer(max_features=5000)
stem = StemmerFactory().create_stemmer()
stopword = StopWordRemoverFactory().create_stop_word_remover()

user_rating_data = pd.read_excel('https://github.com/WayGo12/WayGoApp/raw/main/WayGo-ML/dataset/user_rating_dataset.xlsx')
places_data = pd.read_excel('https://github.com/WayGo12/WayGoApp/raw/main/WayGo-ML/dataset/places_dataset.xlsx')
user_data = pd.read_excel('https://github.com/WayGo12/WayGoApp/raw/main/WayGo-ML/dataset/user_id_dataset.xlsx')

data_recommend = pd.merge(user_rating_data.groupby('Place_ID')['Place_Rating'].mean(), places_data, on='Place_ID')
data_copy1 = data_recommend.copy()

def prepare_data(user_rating_data):
    data_collaborative_filtering = user_rating_data.copy()

    global user_to_user_encoded, user_encoded_to_user, resto_to_resto_encoded, resto_encoded_to_resto

    user_ids = data_collaborative_filtering['ID_user'].unique().tolist()
    user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
    user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}

    resto_ids = data_collaborative_filtering['Place_ID'].unique().tolist()
    resto_to_resto_encoded = {x: i for i, x in enumerate(resto_ids)}
    resto_encoded_to_resto = {i: x for i, x in enumerate(resto_ids)}


    data_collaborative_filtering['user'] = data_collaborative_filtering['ID_user'].map(user_to_user_encoded)
    data_collaborative_filtering['place'] = data_collaborative_filtering['Place_ID'].map(resto_to_resto_encoded)

    num_users = len(user_to_user_encoded)
    num_resto = len(resto_encoded_to_resto)
    data_collaborative_filtering['Place_Rating'] = data_collaborative_filtering['Place_Rating'].values.astype(np.float32)
    min_rating = min(data_collaborative_filtering['Place_Rating'])
    max_rating = max(data_collaborative_filtering['Place_Rating'])

    data_collaborative_filtering = data_collaborative_filtering.sample(frac=1, random_state=42)

    x = data_collaborative_filtering[['user', 'place']].values
    y = data_collaborative_filtering['Place_Rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values
    train_indices = int(0.8 * data_collaborative_filtering.shape[0])
    x_train, x_val, y_train, y_val = (
        x[:train_indices],
        x[train_indices:],
        y[:train_indices],
        y[train_indices:]
    )

    return x_train, x_val, y_train, y_val, num_users, num_resto, user_to_user_encoded, user_encoded_to_user, resto_to_resto_encoded, resto_encoded_to_resto


def create_model(num_users, num_resto, embedding_size):
    class RecommenderNet(tf.keras.Model):
        def __init__(self, num_users, num_resto, embedding_size, **kwargs):
            super(RecommenderNet, self).__init__(**kwargs)
            self.num_users = num_users
            self.num_resto = num_resto
            self.embedding_size = embedding_size
            self.user_embedding = layers.Embedding(
                num_users,
                embedding_size,
                embeddings_initializer='he_normal',
                embeddings_regularizer=keras.regularizers.l2(1e-6)
            )
            self.user_bias = layers.Embedding(num_users, 1)
            self.resto_embedding = layers.Embedding(
                num_resto,
                embedding_size,
                embeddings_initializer='he_normal',
                embeddings_regularizer=keras.regularizers.l2(1e-6)
            )
            self.resto_bias = layers.Embedding(num_resto, 1)

        def call(self, inputs):
            user_vector = self.user_embedding(inputs[:, 0])
            user_bias = self.user_bias(inputs[:, 0])
            resto_vector = self.resto_embedding(inputs[:, 1])
            resto_bias = self.resto_bias(inputs[:, 1])

            dot_user_resto = tf.tensordot(user_vector, resto_vector, 2)

            x = dot_user_resto + user_bias + resto_bias
            return tf.nn.sigmoid(x)

    model = RecommenderNet(num_users, num_resto, embedding_size)
    model.compile(
        loss=tf.keras.losses.BinaryCrossentropy(),
        optimizer=keras.optimizers.Adam(learning_rate=0.001),
        metrics=[tf.keras.metrics.RootMeanSquaredError()]
    )

    return model


def train_model(model, x_train, y_train, x_val, y_val, batch_size, epochs):
    history = model.fit(
        x=x_train,
        y=y_train,
        batch_size=batch_size,
        epochs=epochs,
        validation_data=(x_val, y_val)
    )

    # Get the final accuracy from the history
    final_accuracy = history.history['val_root_mean_squared_error'][-1]

    return history, final_accuracy


def collaborative_filtering_recommender(places_data, user_rating_data, embedding_size, batch_size, epochs, save_model_path=None):
    x_train, x_val, y_train, y_val, num_users, num_resto, user_to_user_encoded, user_encoded_to_user, resto_to_resto_encoded, resto_encoded_to_resto = prepare_data(user_rating_data)
    model = create_model(num_users, num_resto, embedding_size)
    history, final_accuracy = train_model(model, x_train, y_train, x_val, y_val, batch_size, epochs)
    if save_model_path:
        model.save(save_model_path, save_format='tf')
        converter = tf.lite.TFLiteConverter.from_saved_model(save_model_path)
        tflite_model = converter.convert()
        tflite_model_path = save_model_path + '.tflite'
        with open(tflite_model_path, 'wb') as f:
            f.write(tflite_model)

    return model, history, final_accuracy



model, history, final_accuracy = collaborative_filtering_recommender(places_data, user_rating_data, 50, 8, 1000, save_model_path='model')

import matplotlib.pyplot as plt

def plot_loss(history):
    loss = history.history['loss']
    val_loss = history.history['val_loss']
    epochs = range(1, len(loss) + 1)

    plt.figure()
    plt.plot(epochs, loss, 'b', label='Training Loss')
    plt.plot(epochs, val_loss, 'r', label='Validation Loss')
    plt.title('Training and Validation Loss')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()
    plt.show()

# Assuming 'history' is the returned history object from the model training
plot_loss(history)

model, history, final_accuracy = collaborative_filtering_recommender(places_data, user_rating_data, 50, 8, 100, save_model_path='model')

import matplotlib.pyplot as plt

def plot_loss(history):
    loss = history.history['loss']
    val_loss = history.history['val_loss']
    epochs = range(1, len(loss) + 1)

    plt.figure()
    plt.plot(epochs, loss, 'b', label='Training Loss')
    plt.plot(epochs, val_loss, 'r', label='Validation Loss')
    plt.title('Training and Validation Loss')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()
    plt.show()

# Assuming 'history' is the returned history object from the model training
plot_loss(history)

import matplotlib.pyplot as plt

def plot_loss(history):
    loss = history.history['root_mean_squared_error']
    val_loss = history.history['val_root_mean_squared_error']
    epochs = range(1, len(loss) + 1)

    plt.figure()
    plt.plot(epochs, loss, 'b', label='Training RMSE')
    plt.plot(epochs, val_loss, 'r', label='Validation RMSE')
    plt.title('Training and Validation RMSE')
    plt.xlabel('Epochs')
    plt.ylabel('RMSE')
    plt.legend()
    plt.show()

# Assuming 'history' is the returned history object from the model training
plot_loss(history)

model.summary()

layer_configs = []

# Iterate over the layers in the model and retrieve their configurations
for layer in model.layers:
    layer_configs.append(layer.get_config())

# Display the layer configurations
for config in layer_configs:
    print(config)

import pandas as pd

layer_configs = []

# Iterate over the layers in the model and retrieve their configurations
for layer in model.layers:
    layer_configs.append(layer.get_config())

# Create a DataFrame from the layer configurations
df = pd.DataFrame(layer_configs)

# Display the DataFrame
df

model_1, history_1, final_accuracy_1 = collaborative_filtering_recommender(places_data, user_rating_data, 50, 8, 10, save_model_path='model')

import matplotlib.pyplot as plt

def plot_loss(history):
    loss = history.history['loss']
    val_loss = history.history['val_loss']
    epochs = range(1, len(loss) + 1)

    plt.figure()
    plt.plot(epochs, loss, 'b', label='Training Loss')
    plt.plot(epochs, val_loss, 'r', label='Validation Loss')
    plt.title('Training and Validation Loss')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()
    plt.show()

# Assuming 'history' is the returned history object from the model training
plot_loss(history_1)

def recommend_by_collaborative_filtering(model, places_data, user_rating_data, user_id):
    resto_df = places_data
    df = user_rating_data
    resto_visited_by_user = df[df.ID_user == user_id]
    resto_not_visited = resto_df[~resto_df['Place_ID'].isin(resto_visited_by_user.Place_ID.values)]['Place_ID']
    resto_not_visited = list(
        set(resto_not_visited).intersection(resto_to_resto_encoded.keys())
    )
    resto_not_visited = list(map(resto_to_resto_encoded.get, resto_not_visited))

    user_encoder = user_to_user_encoded[user_id]
    user_resto_array = np.hstack(([[user_encoder]] * len(resto_not_visited), np.array(resto_not_visited)[:, None]))
    ratings = model.predict(user_resto_array).flatten()
    top_ratings_indices = ratings.argsort()[-25:][::-1]
    recommended_resto_ids = [resto_encoded_to_resto.get(resto_not_visited[index]) for index in top_ratings_indices]
    recommended_resto_info = resto_df[resto_df['Place_ID'].isin(recommended_resto_ids)][['Place_Name', 'Latitude', 'Longitude', 'Place_Category']].values.tolist()

    recommended_places = {
        'Nama Tempat': [],
        'Latitude': [],
        'Longitude': [],
        'Kategori' : []
    }

    for place_info in recommended_resto_info:
        recommended_places['Nama Tempat'].append(place_info[0])
        recommended_places['Latitude'].append(place_info[1])
        recommended_places['Longitude'].append(place_info[2])
        recommended_places['Kategori'].append(place_info[3])

    return recommended_places

def haversine_distance(coord1, coord2):
    # Calculate the distance using Haversine formula
    return geodesic(coord1, coord2).kilometers

def find_closest_place(current_place, places_data, valid_categories):
    current_coord = (places_data['Latitude'][current_place], places_data['Longitude'][current_place])
    valid_places = [(i, (places_data['Latitude'][i], places_data['Longitude'][i])) for i in range(len(places_data['Nama Tempat']))
                    if places_data['Kategori'][i] in valid_categories and i != current_place]
    if not valid_places:
        return None
    closest_place, closest_distance = min(valid_places, key=lambda x: haversine_distance(current_coord, x[1]))
    return closest_place

def generate_rundown_for_user(user_data):
    places_data = {
        'Nama Tempat': user_data['Nama Tempat'],
        'Latitude': user_data['Latitude'],
        'Longitude': user_data['Longitude'],
        'Kategori': user_data['Kategori']
    }

    # Find the first accommodation place
    accommodation_place = user_data['Kategori'].index('Accomodation')

    # 9 PM - 6 AM: Accommodation
    rundown = {'9 PM - 6 AM': [places_data['Nama Tempat'][accommodation_place]]}

    # 6 AM - 8 AM: Culinary (Breakfast)
    culinary_place = find_closest_place(accommodation_place, places_data, ['Culinary'])
    rundown['6 AM - 8 AM'] = [places_data['Nama Tempat'][culinary_place]]

    # 8 AM - 10 AM: Activity
    valid_activity_categories = ['Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    activity_place = find_closest_place(culinary_place, places_data, valid_activity_categories)
    rundown['8 AM - 10 AM'] = [places_data['Nama Tempat'][activity_place]]

    # 10 AM - 12 PM: Activity
    valid_activity_categories_10_to_12 = ['Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    activity_place_10_to_12 = find_closest_place(activity_place, places_data, valid_activity_categories_10_to_12)
    rundown['10 AM - 12 PM'] = [places_data['Nama Tempat'][activity_place_10_to_12]]

    # 12 PM - 1 PM: Culinary (Lunch)
    culinary_place_12_to_1 = find_closest_place(activity_place_10_to_12, places_data, ['Culinary'])
    rundown['12 PM - 1 PM'] = [places_data['Nama Tempat'][culinary_place_12_to_1]]

    # 1 PM - 3 PM: Activity
    valid_activity_categories_1_to_3 = ['Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    activity_place_1_to_3 = find_closest_place(culinary_place_12_to_1, places_data, valid_activity_categories_1_to_3)
    rundown['1 PM - 3 PM'] = [places_data['Nama Tempat'][activity_place_1_to_3]]

    # 3 PM - 5 PM: Activity
    valid_activity_categories_3_to_5 = ['Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    activity_place_3_to_5 = find_closest_place(activity_place_1_to_3, places_data, valid_activity_categories_3_to_5)
    rundown['3 PM - 5 PM'] = [places_data['Nama Tempat'][activity_place_3_to_5]]

    # 5 PM - 7 PM: Culinary (Dinner)
    culinary_place_5_to_7 = find_closest_place(activity_place_3_to_5, places_data, ['Culinary'])
    rundown['5 PM - 7 PM'] = [places_data['Nama Tempat'][culinary_place_5_to_7]]

    # 7 PM - 9 PM: Shopping
    shopping_place_7_to_9 = find_closest_place(culinary_place_5_to_7, places_data, ['Shopping'])
    rundown['7 PM - 9 PM'] = [places_data['Nama Tempat'][shopping_place_7_to_9]]

    return rundown

save_model_path = 'model'  # Replace with the desired save path
recommender = collaborative_filtering_recommender(places_data, user_rating_data, embedding_size=50, batch_size=8, epochs=10, save_model_path=save_model_path)

user_id = 12 # Replace 123 with the actual user ID
recommendations = recommend_by_collaborative_filtering(recommender, places_data, user_rating_data, user_id)

recommendations

df_rec = pd.DataFrame(recommendations)
df_rec

from geopy.distance import geodesic

def haversine_distance(coord1, coord2):
    # Calculate the distance using the Haversine formula
    return geodesic(coord1, coord2).kilometers

def find_closest_place(current_place, places_data, valid_categories):
    current_coord = (places_data['Latitude'][current_place], places_data['Longitude'][current_place])
    valid_places = [(i, (places_data['Latitude'][i], places_data['Longitude'][i])) for i in range(len(places_data['Nama Tempat']))
                    if places_data['Kategori'][i] in valid_categories and i != current_place]
    if not valid_places:
        return None
    closest_place, closest_distance = min(valid_places, key=lambda x: haversine_distance(current_coord, x[1]))
    return closest_place

def delete_processed_place(places_data, index):
    del places_data['Nama Tempat'][index]
    del places_data['Latitude'][index]
    del places_data['Longitude'][index]
    del places_data['Kategori'][index]

def generate_rundown_for_user(user_data):
    places_data = {
        'Nama Tempat': user_data['Nama Tempat'],
        'Latitude': user_data['Latitude'],
        'Longitude': user_data['Longitude'],
        'Kategori': user_data['Kategori']
    }

    # Find the first accommodation place
    accommodation_place = user_data['Kategori'].index('Accomodation')

    # 9 PM - 6 AM: Accommodation
    rundown = [{'Jam Rundown': '9 PM - 6 AM',
                'Nama Tempat': places_data['Nama Tempat'][accommodation_place],
                'Kategori': places_data['Kategori'][accommodation_place],
                'Jarak Tempat': None}]
    delete_processed_place(places_data, accommodation_place)

    # 6 AM - 8 AM: Culinary (Breakfast)
    culinary_place = find_closest_place(accommodation_place, places_data, ['Culinary'])
    distance = haversine_distance((places_data['Latitude'][accommodation_place], places_data['Longitude'][accommodation_place]),
                                  (places_data['Latitude'][culinary_place], places_data['Longitude'][culinary_place]))
    rundown.append({'Jam Rundown': '6 AM - 8 AM',
                    'Nama Tempat': places_data['Nama Tempat'][culinary_place],
                    'Kategori': places_data['Kategori'][culinary_place],
                    'Jarak Tempat': distance})
    delete_processed_place(places_data, culinary_place)

    # 8 AM - 10 AM: Activity
    valid_activity_categories = ['Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    activity_place = find_closest_place(culinary_place, places_data, valid_activity_categories)
    distance = haversine_distance((places_data['Latitude'][culinary_place], places_data['Longitude'][culinary_place]),
                                  (places_data['Latitude'][activity_place], places_data['Longitude'][activity_place]))
    rundown.append({'Jam Rundown': '8 AM - 10 AM',
                    'Nama Tempat': places_data['Nama Tempat'][activity_place],
                    'Kategori': places_data['Kategori'][activity_place],
                    'Jarak Tempat': distance})
    delete_processed_place(places_data, activity_place)

    # 10 AM - 12 PM: Activity
    valid_activity_categories_10_to_12 = ['Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    activity_place_10_to_12 = find_closest_place(activity_place, places_data, valid_activity_categories_10_to_12)
    distance = haversine_distance((places_data['Latitude'][activity_place], places_data['Longitude'][activity_place]),
                                  (places_data['Latitude'][activity_place_10_to_12], places_data['Longitude'][activity_place_10_to_12]))
    rundown.append({'Jam Rundown': '10 AM - 12 PM',
                    'Nama Tempat': places_data['Nama Tempat'][activity_place_10_to_12],
                    'Kategori': places_data['Kategori'][activity_place_10_to_12],
                    'Jarak Tempat': distance})
    delete_processed_place(places_data, activity_place_10_to_12)

    # 12 PM - 1 PM: Culinary (Lunch)
    culinary_place_12_to_1 = find_closest_place(activity_place_10_to_12, places_data, ['Culinary'])
    distance = haversine_distance((places_data['Latitude'][activity_place_10_to_12], places_data['Longitude'][activity_place_10_to_12]),
                                  (places_data['Latitude'][culinary_place_12_to_1], places_data['Longitude'][culinary_place_12_to_1]))
    rundown.append({'Jam Rundown': '12 PM - 1 PM',
                    'Nama Tempat': places_data['Nama Tempat'][culinary_place_12_to_1],
                    'Kategori': places_data['Kategori'][culinary_place_12_to_1],
                    'Jarak Tempat': distance})
    delete_processed_place(places_data, culinary_place_12_to_1)

    # 1 PM - 3 PM: Activity
    valid_activity_categories_1_to_3 = ['Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    activity_place_1_to_3 = find_closest_place(culinary_place_12_to_1, places_data, valid_activity_categories_1_to_3)
    distance = haversine_distance((places_data['Latitude'][culinary_place_12_to_1], places_data['Longitude'][culinary_place_12_to_1]),
                                  (places_data['Latitude'][activity_place_1_to_3], places_data['Longitude'][activity_place_1_to_3]))
    rundown.append({'Jam Rundown': '1 PM - 3 PM',
                    'Nama Tempat': places_data['Nama Tempat'][activity_place_1_to_3],
                    'Kategori': places_data['Kategori'][activity_place_1_to_3],
                    'Jarak Tempat': distance})
    delete_processed_place(places_data, activity_place_1_to_3)

    # 3 PM - 5 PM: Activity
    valid_activity_categories_3_to_5 = ['Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    activity_place_3_to_5 = find_closest_place(activity_place_1_to_3, places_data, valid_activity_categories_3_to_5)
    distance = haversine_distance((places_data['Latitude'][activity_place_1_to_3], places_data['Longitude'][activity_place_1_to_3]),
                                  (places_data['Latitude'][activity_place_3_to_5], places_data['Longitude'][activity_place_3_to_5]))
    rundown.append({'Jam Rundown': '3 PM - 5 PM',
                    'Nama Tempat': places_data['Nama Tempat'][activity_place_3_to_5],
                    'Kategori': places_data['Kategori'][activity_place_3_to_5],
                    'Jarak Tempat': distance})
    delete_processed_place(places_data, activity_place_3_to_5)

    # 5 PM - 7 PM: Culinary (Dinner)
    culinary_place_5_to_7 = find_closest_place(activity_place_3_to_5, places_data, ['Culinary'])
    distance = haversine_distance((places_data['Latitude'][activity_place_3_to_5], places_data['Longitude'][activity_place_3_to_5]),
                                  (places_data['Latitude'][culinary_place_5_to_7], places_data['Longitude'][culinary_place_5_to_7]))
    rundown.append({'Jam Rundown': '5 PM - 7 PM',
                    'Nama Tempat': places_data['Nama Tempat'][culinary_place_5_to_7],
                    'Kategori': places_data['Kategori'][culinary_place_5_to_7],
                    'Jarak Tempat': distance})
    delete_processed_place(places_data, culinary_place_5_to_7)

    # 7 PM - 9 PM: Shopping
    shopping_place_7_to_9 = find_closest_place(culinary_place_5_to_7, places_data, ['Shopping'])
    distance = haversine_distance((places_data['Latitude'][culinary_place_5_to_7], places_data['Longitude'][culinary_place_5_to_7]),
                                  (places_data['Latitude'][shopping_place_7_to_9], places_data['Longitude'][shopping_place_7_to_9]))
    rundown.append({'Jam Rundown': '7 PM - 9 PM',
                    'Nama Tempat': places_data['Nama Tempat'][shopping_place_7_to_9],
                    'Kategori': places_data['Kategori'][shopping_place_7_to_9],
                    'Jarak Tempat': distance})
    delete_processed_place(places_data, shopping_place_7_to_9)

    return rundown

rundown1 = generate_rundown_for_user(recommendations)
rundown1

"""# Start Point

**East Bali:**
*   Latitude: Approximately -8.471148
*   Longitude: Approximately 115.665717

**North Bali:**
*   Latitude: Approximately -8.182740
*   Longitude: Approximately 115.136624

**West Bali:**
*   Latitude: Approximately -8.409518
*   Longitude: Approximately 114.979448

**South Bali:**
*   Latitude: Approximately -8.409518
*   Longitude: Approximately 115.188916
"""

places_data

"""# Drafts"""

def create_rundown(output_data):
    rundown = {
        '9 PM - 6 AM': [],
        '7 AM - 8 AM': [],
        '8 AM - 10 AM': [],
        '10 AM - 12 PM': [],
        '12 PM - 1 PM': [],
        '1 PM - 3 PM': [],
        '3 PM - 5 PM': [],
        '5 PM - 7 PM': [],
        '7 PM - 9 PM': []
    }

    for i in range(len(output_data['Nama Tempat'])):
        category = output_data['Kategori'][i]
        place = output_data['Nama Tempat'][i]

        if category == 'Accommodation':
            rundown['9 PM - 6 AM'].append(place)
        elif category == 'Culinary':
            if i % 2 == 0:
                rundown['7 AM - 8 AM'].append(place)
            else:
                rundown['12 PM - 1 PM'].append(place)
                rundown['5 PM - 7 PM'].append(place)
        else:
            rundown['8 AM - 10 AM'].append(place)
            rundown['10 AM - 12 PM'].append(place)
            rundown['1 PM - 3 PM'].append(place)
            rundown['3 PM - 5 PM'].append(place)
            rundown['7 PM - 9 PM'].append(place)

    return rundown

def create_rundown(output_data):
    categories = ['Culinary', 'Accommodation', 'Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    time_intervals = ['9 PM - 6 AM', '7 AM - 8 AM', '8 AM - 10 AM', '10 AM - 12 PM', '12 PM - 1 PM', '1 PM - 3 PM', '3 PM - 5 PM', '5 PM - 7 PM', '7 PM - 9 PM']

    # Create a dictionary to store the locations for each time interval
    rundown = {interval: [] for interval in time_intervals}

    for i in range(len(output_data['Nama Tempat'])):
        place = output_data['Nama Tempat'][i]
        category = output_data['Kategori'][i]
        latitude = output_data['Latitude'][i]
        longitude = output_data['Longitude'][i]

        # Find the appropriate time interval based on the category
        if category == 'Accomodation':
            interval = '9 PM - 6 AM'
        elif category == 'Culinary':
            if i % 2 == 0:
                interval = '7 AM - 8 AM'
            else:
                interval = '12 PM - 1 PM'
        else:
            if i % 4 == 0:
                interval = '8 AM - 10 AM'
            elif i % 3 == 0:
                interval = '10 AM - 12 PM'
            elif i % 5 == 0:
                interval = '1 PM - 3 PM'
            elif i % 6 == 0:
                interval = '3 PM - 5 PM'
            else:
                interval = '5 PM - 7 PM'

        # Add the place and its coordinates to the corresponding time interval
        rundown[interval].append({'place': place, 'category': category, 'latitude': latitude, 'longitude': longitude})

    return rundown

def create_rundown(output_data):
    categories = ['Culinary', 'Accommodation', 'Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    time_intervals = ['9 PM - 6 AM', '7 AM - 8 AM', '8 AM - 10 AM', '10 AM - 12 PM', '12 PM - 1 PM', '1 PM - 3 PM', '3 PM - 5 PM', '5 PM - 7 PM', '7 PM - 9 PM']

    # Create a dictionary to store the locations for each time interval
    rundown = {interval: [] for interval in time_intervals}

    for i in range(len(output_data['Nama Tempat'])):
        place = output_data['Nama Tempat'][i]
        category = output_data['Kategori'][i]
        latitude = output_data['Latitude'][i]
        longitude = output_data['Longitude'][i]

        # Find the appropriate time interval based on the category
        if category == 'Accomodation':
            interval = '9 PM - 6 AM'
        elif category == 'Culinary':
                interval = '7 AM - 8 AM' or '12 PM - 1 PM' or '5 PM - 7 PM'
        else:
            if category == "Nautical" or "Nature" or "History" or "Entertainment" or "Shopping" or "Art":
                interval = '8 AM - 10 AM' or '10 AM - 12 PM' or '1 PM - 3 PM' or '3 PM - 5 PM'
            if category == "Shopping":
              interval = '7 PM - 9 PM'

        # Add the place and its coordinates to the corresponding time interval
        rundown[interval].append({'place': place, 'category': category, 'latitude': latitude, 'longitude': longitude})

    return rundown

def create_rundown(output_data):
    categories = ['Culinary', 'Accommodation', 'Nautical', 'Nature', 'History', 'Entertainment', 'Shopping', 'Art']
    time_intervals = ['9 PM - 6 AM', '6 AM - 8 AM', '8 AM - 10 AM', '10 AM - 12 PM', '12 PM - 1 PM', '1 PM - 3 PM', '3 PM - 5 PM', '5 PM - 7 PM', '7 PM - 9 PM']

    # Create a dictionary to store the locations for each time interval
    rundown = {interval: [] for interval in time_intervals}

    for i in range(len(output_data['Nama Tempat'])):
        place = output_data['Nama Tempat'][i]
        category = output_data['Kategori'][i]
        latitude = output_data['Latitude'][i]
        longitude = output_data['Longitude'][i]

        # Find the appropriate time interval based on the category
        if category == 'Accomodation':
            interval = '9 PM - 6 AM'
        elif category == 'Culinary' and any(interval in ['6 AM - 8 AM', '12 PM - 1 PM', '5 PM - 7 PM'] for interval in time_intervals):
            interval = '6 AM - 8 AM' if '7 AM - 8 AM' in time_intervals else '12 PM - 1 PM' if '12 PM - 1 PM' in time_intervals else '5 PM - 7 PM'
        elif category in ["Nautical", "Nature", "History", "Entertainment", "Shopping", "Art"] and any(interval in ['8 AM - 10 AM', '10 AM - 12 PM', '1 PM - 3 PM', '3 PM - 5 PM'] for interval in time_intervals):
            interval = '8 AM - 10 AM' if '8 AM - 10 AM' in time_intervals else '10 AM - 12 PM' if '10 AM - 12 PM' in time_intervals else '1 PM - 3 PM' if '1 PM - 3 PM' in time_intervals else '3 PM - 5 PM'
        elif category == "Shopping" and '7 PM - 9 PM' in time_intervals:
            interval = '7 PM - 9 PM'
        else:
            interval = None

        # Add the place and its coordinates to the corresponding time interval
        if interval:
            rundown[interval].append({'place': place, 'category': category, 'latitude': latitude, 'longitude': longitude})

    return rundown

import math

def calculate_distance(lat1, lon1, lat2, lon2):
    """
    Calculate the distance between two points on the Earth's surface
    using the Haversine formula.
    """
    # Convert latitude and longitude from degrees to radians
    lat1_rad = math.radians(lat1)
    lon1_rad = math.radians(lon1)
    lat2_rad = math.radians(lat2)
    lon2_rad = math.radians(lon2)

    # Radius of the Earth in kilometers
    radius = 6371

    # Haversine formula
    dlat = lat2_rad - lat1_rad
    dlon = lon2_rad - lon1_rad
    a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = radius * c

    return distance

def filter_by_closest_location(recommendations, start_lat, start_lon):
    """
    Filter the recommended places by the closest location to the start point.
    """
    filtered_recommendations = {}
    for time_interval, places in recommendations.items():
        closest_place = None
        closest_distance = float('inf')
        for place in places:
            distance = calculate_distance(start_lat, start_lon, place['latitude'], place['longitude'])
            if distance < closest_distance:
                closest_place = place
                closest_distance = distance
        if closest_place is not None:
            filtered_recommendations[time_interval] = [closest_place]

    return filtered_recommendations